### 5. Constructor
##### 5.1 생성자

생성자가 instance를 생성하는 것이 아니다! ** 연산자 new **가 생성하는 것이다!!! keep in mind!

##### 5.4 생성자에서 다른 생성자 호출 그리고 this

한 생성자에서 다른 생성자 호출시 반드시 <u>첫 줄</u>에서 해야 함!
 - 그렇지 않을 경우 이미 위에서 초기화한 어떤 값을 아래에서 생성자를 호출함으로 날려 버릴 수가 있음.

this
 - 참조변수
 - 인스턴스 자신을 가리킴
 - 인스턴스의 주소가 존재
 - cf)this(): this()는 생성자이며, 같은 클래스의 다른 생성자를 호출할때 사용한다.
 
#### 6. 변수의 초기화
##### 6.1 변수의 초기화

멤버변수(클래스 변수, 인스턴스 변수)는 초기화 없이 사용할 수 있지만(기본값으로 초기화)
지역 변수(메서드의 변수)는 사용전 반드시 초기화를 거쳐야 한다.
 
멤버변수의 초기화 방법
 1. 명시적 초기화(explicit initialization)
 2. 생성자(constructor)
 3. 초기화 블럭(initialization block)
 
##### 6.3 초기화 블럭(initialization block)

초기화 블럭의 종류
- 클래스 초기화 블럭
  - 클래스 메모리에 처음 로딩될 때 한 번 수행
```java
static { ... }
```

- 인스턴스 초기화 블럭
  - 생성자와 같이 인스턴스를 생성할 때 마다 수행(생성자보다 우선)
```java
{ ... }
```

### 7. 객체지향 프로그래밍
#### 2. 오버라이딩(overriding)
##### 2.2 오버라이딩의 조건
1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위일 수 없다.
 - 조상 클래스의 메서드가 protected라면, 자식은 protected or public 이어야 함
 - public -> protected, (default), private
2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
 - 갯수뿐만이 문제가 아니라 Exception의 상속 관계도 고려해야 한다.
 
##### 2.5 super() - 조상 클래스의 생성자
부모클래스의 생성자에 매개변수가 없는 기본형태의 생성자( 클래스명(){ ... } )가 없으면, 상속받은 클래스의 생성자에 반드시 부모 생성자를 명시해야함.
안그러면 컴파일러가 super(); 를 default로 추가하므로 컴파일 에러 발생.

#### 3. package와 import
##### 3.2 패키지 선언
패키지명은 클래스와 구분하기 위해 '소문자'로 쓰는 것을 원칙으로 함
